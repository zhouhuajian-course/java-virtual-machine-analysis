package escape.analysis;

/**
 * 逃逸分析
 *
 * “Java 中的对象是否都分配在堆内存中？”
 * ——“不尽然”
 *
 * 前文简单提到了，如果对象都是分配在堆内存中，那么随着对象数量的增加，必然会涉及到 GC 的频繁运行，所以为了缓解上述情况，“逃逸分析” 由此诞生。
 *
 * 逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。
 *
 * 在方法中创建对象之后，如果这个对象除了在方法体中还在其它地方被引用了，此时如果方法执行完毕，由于该对象有被引用，
 * 所以 GC 有可能是无法立即回收的，此时便成为 内存逃逸现象。
 *
 * 逃逸 是一个动词，比如 A 从 B 中逃逸，那么此时这个 A 指的就是方法中创建的对象，B 指的就是这个方法体，
 * 即可以简单理解成这个对象逃逸出这个方法体。
 *
 * 开启逃逸分析：-XX:+DoEscapeAnalysis
 * 关闭逃逸分析：-XX:-DoEscapeAnalysis
 * 显示分析结果：-XX:+PrintEscapeAnalysis
 *
 * 297500
 * 352300
 * 312500
 * 327100
 * 340200
 * 324400
 * 319800
 * 265300
 * 90800
 * 71300
 * 78100
 * 71600
 * 72600
 * 68100
 * 65500
 * 71100
 * 67000
 * 88300
 * 72700
 * 63200
 * 65100
 * 83600
 * 79400
 * 88300
 * 82300
 * 2900
 * 2900
 * 2900
 * 6800
 * 2900
 *
 * -XX:-DoEscapeAnalysis
 *
 * 284600
 * 300700
 * 296600
 * 323500
 * 367300
 * 325600
 * 323800
 * 260200
 * 100400
 * 82700
 * 72800
 * 77700
 * 71800
 * 92300
 * 74400
 * 83300
 * 76600
 * 81900
 * 69300
 * 71500
 * 78600
 * 68100
 * 68400
 * 108600
 * 117700
 * 80900
 * 57200
 * 50100
 * 63700
 * 85300
 */
public class EscapeAnalysis {
    public static void main(String[] args) {
        for (int i = 0; i < 30; i++) {
            long startTime = System.nanoTime();
            for (int j = 0; j < 10000; j++) {
                new Object();
            }
            long endTime = System.nanoTime();
            System.out.println(endTime - startTime);
        }
    }
}
